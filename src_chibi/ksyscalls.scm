(import (chibi)
        (chibi io)
        (chibi json)
        (srfi 1)
        (srfi 69)
        (srfi 159 base))

(define header
"/*
 * This file is part of Jehanne.
 *
 * Copyright (C) 2016 Giacomo Tesio <giacomo@tesio.it>
 *
 * Jehanne is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Jehanne is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Jehanne.  If not, see <http://www.gnu.org/licenses/>.
 */
/* automatically generated by ksyscalls */")

(define includes
"
#include \"u.h\"
#include \"../port/lib.h\"
#include \"mem.h\"
#include \"dat.h\"
#include \"fns.h\"
#include \"../port/error.h\"
#include \"ureg.h\"
")

(define fmt-funcs
"
extern void fmtrwdata(Fmt* f, char* a, int n);
extern void fmtuserstring(Fmt* f, const char* a);
extern void fmtuserstringlist(Fmt* f, const char** argv);

")

(define (indent x)
  (space-to (* x 4)))

(define (ureg-arg x)
  (case x
        ((0)    "di")
        ((1)    "si")
        ((2)    "dx")
        ((3)    "r10")
        ((4)    "r8")
        ((5)    "r9")
        (else   "")))

(define (sysret x)
  (case (string->symbol x)
    ((int)       "i")
    ((int32_t)   "i")
    ((long)      "vl")
    ((int64_t)   "vl")
    ((uintptr_t) "p")
    ((void)      "p")
    ((void*)     "v")
    ((char*)     "v")
    ((char**)    "v")
    ((uint8_t*)  "v")
    ((int32_t*)  "v")
    ((uint64_t*) "v")
    ((int64_t*)  "v")
    (else          (string-append "[?? " x "]"))))

(define (format-arg i str)
  (let ((stri (number->string i))
        (sa string-append))
    (case (string->symbol str)
      ((int int32_t)
       (sa "\tjehanne_fmtprint(fmt, \" %%d\", a" stri ");\n"))
      ((unsigned int uint32_t)  ; unsigned int is reserved for flags
       (sa "\tjehanne_fmtprint(fmt, \" %#ux\", a" stri ");\n"))
      ((long int64_t)
       (sa "\tjehanne_fmtprint(fmt, \" %lld\", a" stri ");\n"))
      ((unsigned long uint64_t)
       (sa "\tjehanne_fmtprint(fmt, \" %#lud\", a" stri ");\n" i))
      ((void* uint8_t* const void* const uint8_t*)
       (sa "\tjehanne_fmtprint(fmt, \" %#p\", a" stri");\n"))
      ((int32_t* int* const int32_t* const int*)
       (sa "\tjehanne_fmtprint(fmt, \" %#p(%d)\", a" stri ", a" stri ");\n"))
      ((const char* char*)
       (sa "\tfmtuserstring(fmt, a" stri ");\n"))
      ((const char** char**)
       (sa "\tfmtuserstringlist(fmt, a" stri ");\n"))
      (else
       (sa "[?? " str "]")))))

(define (format-ret t)
  (let ((sysret (sysret t))
        (sa string-append))
    (case (string->symbol t)
      ((int int32_t)
       (sa "\tjehanne_fmtprint(fmt, \" %d\", ret->" sysret ");\n"))
      ((unsigned int uint32_t)  ; unsigned int is reserved for flags
       (sa "\tjehanne_fmtprint(fmt, \" %#ux\", ret->" sysret ");\n"))
      ((long int64_t)
       (sa "\tjehanne_fmtprint(fmt, \" %lld\", ret->" sysret ");\n"))
      ((unsigned long uint64_t void)
       (sa "\tjehanne_fmtprint(fmt, \" %#llud\", ret->" sysret ");\n"))
      ((void* uintptr_t const void* const uintptr_t)
       (sa "\tjehanne_fmtprint(fmt, \" %#p\", ret->" sysret ");\n"))
      ((int32_t* int* const int32_t* const int*)
       (sa "\tjehanne_fmtprint(fmt, \" %#p(%%d)\", ret->" sysret
           ", *ret->" sysret ");\n"))
      ((else)
       (sa "[?? " t "]")))))

(define (format-extern-block syscalls)
  (joined/suffix
    (lambda (x)
      (let* ((name (cdr (assq 'Name x)))
             (ret  (vector-ref (cdr (assq 'Ret x)) 0))
             (args (vector->list (cdr (assq 'Args x)))))
        (joined displayed
                `("extern " ,ret " sys" ,name "("
                    ,(if (= 0 (length args))
                         "void"
                         (joined
                            displayed
                            args
                            ", "))))))
    (vector->list syscalls)
    ");\n"))

(define (generate-wrapper syscall)
  ;TODO
  (let* ((wrapper (make-hash-table))
         (syscall (alist->hash-table syscall))
         (ret0 (vector-ref (hash-table-ref syscall 'Ret) 0))

         (args (vector->list (hash-table-ref syscall 'Args)))
         (argcount (iota (length args)))

         (ret (sysret ret0)))
    (hash-table-set! wrapper 'id (hash-table-ref syscall 'Id))
    (hash-table-set! wrapper 'name (hash-table-ref syscall 'Name))
    (hash-table-set! wrapper 'sysretfield ret)
    (hash-table-set! wrapper 'defaultret
                     (string-append "ret." ret " = (" ret0 ")-1;"))

    ; TODO: Check if using `joined displayed` that much is the way to do it

    (hash-table-set! wrapper 'vars
                      (joined/prefix
                        (lambda (x)
                          (joined displayed
                            `(,(indent 1) ,(car x) " a" ,(numeric (cadr x)) ";")))
                        (zip args argcount)
                        nl))

    (hash-table-set!  wrapper 'commoncode
                      (joined/prefix
                        (lambda (x)
                          (joined displayed
                                  `(,(indent 1)
                                     "a"
                                     ,(numeric (cadr x))
                                     " = ("
                                     ,(car x)
                                     ")ureg->"
                                     ,(ureg-arg (cadr x))
                                     ";")))
                        (zip args argcount)
                        nl))

    (hash-table-set! wrapper 'execcode
                     (joined
                       displayed
                       `(,(indent 1)
                          "ret->"
                          ,(hash-table-ref wrapper 'sysretfield)
                          "= sys" ,(hash-table-ref syscall 'Name)
                          "("
                          ,(joined (lambda (x)
                                     (joined displayed `("a" ,(numeric x))))
                                   argcount
                                   ", ")
                          ");")))
    wrapper))

(define (generate-wrappers syscalls)
  (map generate-wrapper (vector->list syscalls)))


(define (wrap_ wrapper)
;TODO
  (joined displayed
          `("static void" ,nl
            "wrap_" ,(hash-table-ref wrapper 'name) "(ScRet* ret, Ureg* ureg)" ,nl
            "{ "
            ,(hash-table-ref wrapper 'vars)
            ,(hash-table-ref wrapper 'commoncode) ,nl
            ,(hash-table-ref wrapper 'execcode) ,nl
            "}"

            )))

(define (default_syscall_ret-wrapper wrapper)
  (joined displayed
    `( "\tcase" ,(hash-table-ref wrapper 'id) ":" ,nl
      "\t\t",(hash-table-ref wrapper 'defaultret) ,nl
      "\t\tbreak;")))


(define (generate-kernel-code syscalls)
  (let ((wrappers (generate-wrappers syscalls)))
    (show #t
          (displayed header)
          (displayed includes)
          (displayed fmt-funcs)
          (format-extern-block syscalls)
          nl
          nl

          ; TODO
          (joined/suffix
            wrap_
            wrappers
            nl)
          (indent 0)"int nsyscall = " (length wrappers) ";" nl
          (indent 0)"ScRet" nl
          (indent 0)"default_syscall_ret(int syscall)" nl
          (indent 0) "{" nl
          (indent 1)"static ScRet zero;" nl
          (indent 1)"ScRet ret = zero;"  nl
          (indent 1)"switch(syscall){"   nl
          (joined
            displayed
            (map default_syscall_ret-wrapper wrappers)
            nl)
          (indent 1)  "default:" nl
          (indent 2)     "ret.vl = -1;" nl
          (indent 2)     "break;" nl
          (indent 1)  "}" nl
          (indent 1)  "return ret;" nl
          "}")))

(define (main args)
  (if (= 2 (length args))
      (generate-kernel-code
        (cdr (assq 'Syscalls
                   (parse-json
                     (call-with-input-file (cadr args) port->string)))))
      (error "Usage: ksyscalls path/to/sysconf.json\n")))

(main (command-line))
