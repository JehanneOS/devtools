(import (chibi)
        (chibi io)
        (chibi json)
        (srfi 1)
        (srfi 69)
        (srfi 159 base))

(define (ureg-arg x)
  (case x
        ((0)    "di")
        ((1)    "si")
        ((2)    "dx")
        ((3)    "r10")
        ((4)    "r8")
        ((5)    "r9")
        (else   "")))

(define (sysret x)
  (case x
    (("int")       "i")
    (("int32_t")   "i")
    (("long")      "vl")
    (("int64_t")   "vl")
    (("uintptr_t") "p")
    (("void")      "p")
    (("void*")     "v")
    (("char*")     "v")
    (("char**")    "v")
    (("uint8_t*")  "v")
    (("int32_t*")  "v")
    (("uint64_t*") "v")
    (("int64_t*")  "v")
    (else          (string-append "[?? " x "]"))))

(define (format-arg i str)
  (let ((stri (number->string i))
        (sa string-append))
    (case str
      ((or "int" "int32_t")
       (sa "\tjehanne_fmtprint(fmt, \" %%d\", a" stri ");\n"))
      ((or "unsigned int" "uint32_t")  ; unsigned int is reserved for flags
       (sa "\tjehanne_fmtprint(fmt, \" %#ux\", a" stri ");\n"))
      ((or "long" "int64_t")
       (sa "\tjehanne_fmtprint(fmt, \" %lld\", a" stri ");\n"))
      ((or "unsigned long" "uint64_t")
       (sa "\tjehanne_fmtprint(fmt, \" %#lud\", a" stri ");\n" i))
      ((or "void*" "uint8_t*" "const void*" "const uint8_t*")
       (sa "\tjehanne_fmtprint(fmt, \" %#p\", a" stri");\n"))
      ((or "int32_t*" "int*" "const int32_t*" "const int*")
       (sa "\tjehanne_fmtprint(fmt, \" %#p(%d)\", a" stri ", a" stri ");\n"))
      ((or "const char*" "char*")
       (sa "\tfmtuserstring(fmt, a" stri ");\n"))
      ((or "const char**" "char**")
       (sa "\tfmtuserstringlist(fmt, a" stri ");\n"))
      (else
       (sa "[?? " str "]")))))

(define (format-ret t)
  (let ((sysret (sysret t))
        (sa string-append))
    (case t
      ((or "int" "int32_t")
       (sa "\tjehanne_fmtprint(fmt, \" %d\", ret->" sysret ");\n"))
      ((or "unsigned int" "uint32_t")  ; unsigned int is reserved for flags
       (sa "\tjehanne_fmtprint(fmt, \" %#ux\", ret->" sysret ");\n"))
      ((or "long" "int64_t")
       (sa "\tjehanne_fmtprint(fmt, \" %lld\", ret->" sysret ");\n"))
      ((or "unsigned long" "uint64_t" "void")
       (sa "\tjehanne_fmtprint(fmt, \" %#llud\", ret->" sysret ");\n"))
      ((or "void*" "uintptr_t" "const void*" "const uintptr_t")
       (sa "\tjehanne_fmtprint(fmt, \" %#p\", ret->" sysret ");\n"))
      ((or "int32_t*" "int*" "const int32_t*" "const int*")
       (sa "\tjehanne_fmtprint(fmt, \" %#p(%%d)\", ret->" sysret
           ", *ret->" sysret ");\n"))
      ((else)
       (sa "[?? " t "]")))))


(define (generate-externs syscalls)
  (map
    (lambda (x)
      (string-append
        "extern "
        (car (vector->list (cdr (assq 'Ret x))))
        " sys"
        (cdr (assq 'Name x))
        "("
        (let ((args (vector->list (cdr (assq 'Args x)))))
          (if (= 0 (length args))
            "void"
            (apply string-append args)))
        ");\n"))
    (vector->list syscalls)))

(define (generate-wrappers syscalls)
  ;TODO
  nothing
  )


(define (wrap_ wrapper)
;TODO
  (displayed
    "static void
    wrap_"
    (hash-table-ref wrapper name)
    "
    (ScRet* ret, Ureg* ureg)
    {
    "
    (joined/suffix displayed (hash-table-ref wrapper vars) nl)
    (hash-table-ref wrapper commoncode) nl
    (hash-table-ref wrapper execcode) nl
    "}"))



(define (generate-kernel-code syscalls)
  (let ((externs (generate-externs syscalls))
        (wrappers (generate-wrappers syscalls)))
          (show #t
                (displayed
"/*
* This file is part of Jehanne.
*
* Copyright (C) 2016 Giacomo Tesio <giacomo@tesio.it>
*
* Jehanne is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
*
* Jehanne is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Jehanne.  If not, see <http://www.gnu.org/licenses/>.
*/
/* automatically generated by ksyscalls */
#include \"u.h\"
#include \"../port/lib.h\"
#include \"mem.h\"
#include \"dat.h\"
#include \"fns.h\"
#include \"../port/error.h\"
#include \"ureg.h\"

extern void fmtrwdata(Fmt* f, char* a, int n);
extern void fmtuserstring(Fmt* f, const char* a);
extern void fmtuserstringlist(Fmt* f, const char** argv);

")
                  (joined/suffix displayed (generate-externs syscalls) fl)
                  (joined/suffix
                    wrap_
                    wrappers
                    nl)
                  )))

(define (main args)
  (if (= 2 (length args))
      (generate-kernel-code
        (cdr (assq 'Syscalls
                   (parse-json
                     (call-with-input-file (cadr args) port->string)))))
      (error "Usage: ksyscalls path/to/sysconf.json\n")))

(main (command-line))
